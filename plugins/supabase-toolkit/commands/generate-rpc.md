---
allowed-tools: Bash, Read, Glob, Grep, Write, Task, TodoWrite, AskUserQuestion, mcp__plugin_supabase_supabase__list_tables, mcp__plugin_supabase_supabase__execute_sql, mcp__plugin_supabase_supabase__apply_migration
argument-hint: <feature-name>
description: Auto-generate PostgreSQL RPC functions with filters, sorting, and pagination
---

# Supabase Toolkit: Generate RPC

You are a **database architect** generating optimized PostgreSQL RPC functions. This command creates battle-tested functions with window functions for efficient count+results queries, filtering, sorting, and pagination.

## WHY RPC FUNCTIONS?

### Problem: Multiple Queries
```typescript
// âŒ Bad: 2 separate queries
const { count } = await supabase.from('orders').select('*', { count: 'exact', head: true });
const { data } = await supabase.from('orders').select('*').range(0, 19);
```

### Solution: Single RPC with Window Function
```typescript
// âœ… Good: 1 query, count embedded in results
const { data } = await supabase.rpc('get_orders_results', {
  p_limit: 20,
  p_offset: 0
});
// data[0].total_count contains the total!
```

## ARGUMENT PARSING

```
/supabase-toolkit:generate-rpc orders
                               â†‘
                            feature name
```

## STAP 1: Analyseer Feature Config

Zoek naar bestaande feature config:

```bash
# Find feature config
find src/features/[name] -name "config.ts" -o -name "*.config.ts" 2>/dev/null
```

Als config bestaat, lees de filter/sort configuratie.
Als niet, analyseer de tabel structuur.

## STAP 2: Analyseer Tabel Structuur

```sql
-- Get table columns
SELECT
  column_name,
  data_type,
  is_nullable,
  column_default
FROM information_schema.columns
WHERE table_name = '[table_name]'
AND table_schema = 'public'
ORDER BY ordinal_position;
```

```sql
-- Get foreign key relationships
SELECT
  kcu.column_name,
  ccu.table_name AS foreign_table_name,
  ccu.column_name AS foreign_column_name
FROM information_schema.table_constraints AS tc
JOIN information_schema.key_column_usage AS kcu
  ON tc.constraint_name = kcu.constraint_name
JOIN information_schema.constraint_column_usage AS ccu
  ON ccu.constraint_name = tc.constraint_name
WHERE tc.constraint_type = 'FOREIGN KEY'
AND tc.table_name = '[table_name]';
```

## STAP 3: Vraag Configuratie

Als geen config gevonden:

```
Welke filters wil je voor [feature]?

â–¡ status - Status dropdown filter
â–¡ search - Tekst zoeken
â–¡ date_range - Datum periode
â–¡ user_id - Filter op gebruiker
â–¡ organization_id - Filter op organisatie
â–¡ [custom] - Andere filter
```

```
Welke sort opties?

â–¡ created_at - Datum aangemaakt
â–¡ updated_at - Datum gewijzigd
â–¡ name - Naam
â–¡ [custom] - Andere velden
```

## STAP 4: Genereer RPC Functions

### Main Results Function

```sql
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- FUNCTION: get_[feature]_results
-- Description: Get [feature] with filters, sorting, pagination, and total count
-- Generated by: /supabase-toolkit:generate-rpc
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

CREATE OR REPLACE FUNCTION get_[feature]_results(
  -- Filters
  p_status TEXT DEFAULT NULL,
  p_search TEXT DEFAULT NULL,
  p_time_period TEXT DEFAULT 'all',
  p_start_date TIMESTAMPTZ DEFAULT NULL,
  p_end_date TIMESTAMPTZ DEFAULT NULL,
  p_user_id UUID DEFAULT NULL,
  p_organization_id UUID DEFAULT NULL,

  -- Sorting
  p_sort_by TEXT DEFAULT 'created_at',
  p_sort_order TEXT DEFAULT 'desc',

  -- Pagination
  p_limit INT DEFAULT 20,
  p_offset INT DEFAULT 0
)
RETURNS TABLE (
  -- Return columns (match your table + joined data)
  id UUID,
  name TEXT,
  status TEXT,
  created_at TIMESTAMPTZ,
  updated_at TIMESTAMPTZ,
  user_id UUID,

  -- Joined data (if applicable)
  user_email TEXT,
  user_name TEXT,

  -- Window function count
  total_count BIGINT
)
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_start_date TIMESTAMPTZ;
  v_end_date TIMESTAMPTZ;
BEGIN
  -- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  -- CALCULATE DATE RANGE
  -- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  IF p_time_period = 'today' THEN
    v_start_date := DATE_TRUNC('day', NOW());
    v_end_date := DATE_TRUNC('day', NOW()) + INTERVAL '1 day';
  ELSIF p_time_period = 'yesterday' THEN
    v_start_date := DATE_TRUNC('day', NOW()) - INTERVAL '1 day';
    v_end_date := DATE_TRUNC('day', NOW());
  ELSIF p_time_period = '7d' THEN
    v_start_date := NOW() - INTERVAL '7 days';
    v_end_date := NOW();
  ELSIF p_time_period = '30d' THEN
    v_start_date := NOW() - INTERVAL '30 days';
    v_end_date := NOW();
  ELSIF p_time_period = '90d' THEN
    v_start_date := NOW() - INTERVAL '90 days';
    v_end_date := NOW();
  ELSIF p_time_period = 'custom' AND p_start_date IS NOT NULL THEN
    v_start_date := p_start_date;
    v_end_date := COALESCE(p_end_date, NOW());
  ELSE
    -- 'all' or default: no date filter
    v_start_date := NULL;
    v_end_date := NULL;
  END IF;

  -- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  -- MAIN QUERY
  -- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

  RETURN QUERY
  SELECT
    t.id,
    t.name,
    t.status,
    t.created_at,
    t.updated_at,
    t.user_id,

    -- Joined user data
    u.email AS user_email,
    COALESCE(u.raw_user_meta_data->>'full_name', u.email) AS user_name,

    -- Window function for total count (before pagination)
    COUNT(*) OVER() AS total_count

  FROM [table_name] t
  LEFT JOIN auth.users u ON u.id = t.user_id

  WHERE
    -- Status filter
    (p_status IS NULL OR t.status = p_status)

    -- Search filter (case-insensitive)
    AND (
      p_search IS NULL
      OR t.name ILIKE '%' || p_search || '%'
      OR u.email ILIKE '%' || p_search || '%'
    )

    -- Date range filter
    AND (v_start_date IS NULL OR t.created_at >= v_start_date)
    AND (v_end_date IS NULL OR t.created_at < v_end_date)

    -- User filter
    AND (p_user_id IS NULL OR t.user_id = p_user_id)

    -- Organization filter (if applicable)
    AND (p_organization_id IS NULL OR t.organization_id = p_organization_id)

    -- RLS: Only show user's own data (unless admin)
    AND (
      auth.uid() = t.user_id
      OR auth.is_admin()
    )

  -- Dynamic sorting
  ORDER BY
    CASE WHEN p_sort_by = 'created_at' AND p_sort_order = 'asc' THEN t.created_at END ASC,
    CASE WHEN p_sort_by = 'created_at' AND p_sort_order = 'desc' THEN t.created_at END DESC,
    CASE WHEN p_sort_by = 'updated_at' AND p_sort_order = 'asc' THEN t.updated_at END ASC,
    CASE WHEN p_sort_by = 'updated_at' AND p_sort_order = 'desc' THEN t.updated_at END DESC,
    CASE WHEN p_sort_by = 'name' AND p_sort_order = 'asc' THEN t.name END ASC,
    CASE WHEN p_sort_by = 'name' AND p_sort_order = 'desc' THEN t.name END DESC,
    t.created_at DESC -- Default fallback

  -- Pagination
  LIMIT p_limit
  OFFSET p_offset;

END;
$$;

-- Grant execute permission
GRANT EXECUTE ON FUNCTION get_[feature]_results TO authenticated;
```

### Counts Function (for filter badges)

```sql
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
-- FUNCTION: get_[feature]_counts
-- Description: Get counts per status for filter badges
-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

CREATE OR REPLACE FUNCTION get_[feature]_counts(
  p_time_period TEXT DEFAULT 'all',
  p_start_date TIMESTAMPTZ DEFAULT NULL,
  p_end_date TIMESTAMPTZ DEFAULT NULL,
  p_user_id UUID DEFAULT NULL,
  p_organization_id UUID DEFAULT NULL
)
RETURNS TABLE (
  status TEXT,
  count BIGINT
)
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  v_start_date TIMESTAMPTZ;
  v_end_date TIMESTAMPTZ;
BEGIN
  -- Calculate date range (same logic as results function)
  IF p_time_period = 'today' THEN
    v_start_date := DATE_TRUNC('day', NOW());
    v_end_date := DATE_TRUNC('day', NOW()) + INTERVAL '1 day';
  ELSIF p_time_period = 'yesterday' THEN
    v_start_date := DATE_TRUNC('day', NOW()) - INTERVAL '1 day';
    v_end_date := DATE_TRUNC('day', NOW());
  ELSIF p_time_period = '7d' THEN
    v_start_date := NOW() - INTERVAL '7 days';
    v_end_date := NOW();
  ELSIF p_time_period = '30d' THEN
    v_start_date := NOW() - INTERVAL '30 days';
    v_end_date := NOW();
  ELSIF p_time_period = '90d' THEN
    v_start_date := NOW() - INTERVAL '90 days';
    v_end_date := NOW();
  ELSIF p_time_period = 'custom' AND p_start_date IS NOT NULL THEN
    v_start_date := p_start_date;
    v_end_date := COALESCE(p_end_date, NOW());
  END IF;

  RETURN QUERY
  SELECT
    t.status::TEXT,
    COUNT(*)::BIGINT
  FROM [table_name] t
  WHERE
    (v_start_date IS NULL OR t.created_at >= v_start_date)
    AND (v_end_date IS NULL OR t.created_at < v_end_date)
    AND (p_user_id IS NULL OR t.user_id = p_user_id)
    AND (p_organization_id IS NULL OR t.organization_id = p_organization_id)
    AND (auth.uid() = t.user_id OR auth.is_admin())
  GROUP BY t.status;
END;
$$;

GRANT EXECUTE ON FUNCTION get_[feature]_counts TO authenticated;
```

## STAP 5: Genereer TypeScript Types

```typescript
// src/features/[feature]/types.ts

/**
 * Parameters for get_[feature]_results RPC
 */
export interface Get[Feature]ResultsParams {
  p_status?: string;
  p_search?: string;
  p_time_period?: 'today' | 'yesterday' | '7d' | '30d' | '90d' | 'all' | 'custom';
  p_start_date?: string;
  p_end_date?: string;
  p_user_id?: string;
  p_organization_id?: string;
  p_sort_by?: 'created_at' | 'updated_at' | 'name';
  p_sort_order?: 'asc' | 'desc';
  p_limit?: number;
  p_offset?: number;
}

/**
 * Result row from get_[feature]_results
 */
export interface [Feature]ResultRow {
  id: string;
  name: string;
  status: string;
  created_at: string;
  updated_at: string;
  user_id: string;
  user_email: string;
  user_name: string;
  total_count: number;
}

/**
 * Result from get_[feature]_counts
 */
export interface [Feature]CountRow {
  status: string;
  count: number;
}
```

## STAP 6: Genereer Service Function

```typescript
// src/features/[feature]/service.ts

import { supabase } from '@/shared/lib/supabase';
import { Get[Feature]ResultsParams, [Feature]ResultRow, [Feature]CountRow } from './types';

export async function get[Feature]Results(params: Get[Feature]ResultsParams) {
  const { data, error } = await supabase
    .rpc('get_[feature]_results', params);

  if (error) throw error;

  // Extract total count from first row
  const totalCount = data?.[0]?.total_count ?? 0;

  return {
    data: data ?? [],
    totalCount
  };
}

export async function get[Feature]Counts(params: Omit<Get[Feature]ResultsParams, 'p_sort_by' | 'p_sort_order' | 'p_limit' | 'p_offset'>) {
  const { data, error } = await supabase
    .rpc('get_[feature]_counts', params);

  if (error) throw error;

  return data as [Feature]CountRow[];
}
```

## STAP 7: Apply Migration

Vraag de gebruiker:

```
RPC functions gegenereerd. Wil je deze direct toepassen?

1. Ja, apply via Supabase MCP
2. Nee, toon SQL (ik pas handmatig toe)
3. Opslaan als migration bestand
```

Als "Ja", gebruik `mcp__plugin_supabase_supabase__apply_migration`.

## STAP 8: Rapport

```
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                    ğŸ“Š RPC FUNCTIONS GENERATED                              â•‘
â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£
â•‘                                                                            â•‘
â•‘  Feature: [feature]                                                        â•‘
â•‘  Table: [table_name]                                                       â•‘
â•‘                                                                            â•‘
â•‘  FUNCTIONS CREATED                                                         â•‘
â•‘  â”œâ”€ get_[feature]_results Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â· Main query with filters            â•‘
â•‘  â”‚   â”œâ”€ Filters: status, search, date_range, user_id                       â•‘
â•‘  â”‚   â”œâ”€ Sorting: created_at, updated_at, name                              â•‘
â•‘  â”‚   â”œâ”€ Pagination: limit, offset                                          â•‘
â•‘  â”‚   â””â”€ Window function: total_count                                       â•‘
â•‘  â”‚                                                                         â•‘
â•‘  â””â”€ get_[feature]_counts Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â·Â· Counts per status                  â•‘
â•‘      â””â”€ For filter badges                                                  â•‘
â•‘                                                                            â•‘
â•‘  TYPESCRIPT FILES                                                          â•‘
â•‘  â”œâ”€ src/features/[feature]/types.ts Â·Â·Â· RPC parameter types                â•‘
â•‘  â””â”€ src/features/[feature]/service.ts Â· Service wrapper                    â•‘
â•‘                                                                            â•‘
â•‘  USAGE EXAMPLE                                                             â•‘
â•‘  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â•‘
â•‘  â”‚ const { data, totalCount } = await get[Feature]Results({           â”‚   â•‘
â•‘  â”‚   p_status: 'active',                                               â”‚   â•‘
â•‘  â”‚   p_search: 'query',                                                â”‚   â•‘
â•‘  â”‚   p_time_period: '30d',                                             â”‚   â•‘
â•‘  â”‚   p_sort_by: 'created_at',                                          â”‚   â•‘
â•‘  â”‚   p_sort_order: 'desc',                                             â”‚   â•‘
â•‘  â”‚   p_limit: 20,                                                      â”‚   â•‘
â•‘  â”‚   p_offset: 0                                                       â”‚   â•‘
â•‘  â”‚ });                                                                 â”‚   â•‘
â•‘  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â•‘
â•‘                                                                            â•‘
â•‘  STATUS: [Applied / Pending]                                               â•‘
â•‘                                                                            â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
```

## BEST PRACTICES

1. **Always use window functions** for count - no separate query needed
2. **Set search_path** in function definition for security
3. **Use SECURITY DEFINER** carefully - function runs as owner
4. **Include RLS check** in function for defense in depth
5. **Use parameterized queries** - never concatenate user input
6. **Grant minimal permissions** - only `authenticated` role

---

*Onderdeel van [Vibe Coding Academy Tools](https://github.com/mralbertzwolle/vibe-coding-academy-tools)*
